import sys, argparse

import tinyepubbuilder.reader
import tinyepubbuilder.builder


"""
tinyepubbuilder front end tool

Usage: tinyepubbuild [--unzipped] <package-name> \\
       [-c <cover-image>] [-t <title>] [-l <language-tag>] \\
       [--id <identifier>] [--uuid <dns-name>]
Description:
    This is a tool to buid epub from a formatted file-list readable on the
    standard input.

Options:
    --unzipped
    -c, --cover <cover-image>
    -t, --title <title>
    -a, --author <author-name>
    -l, --language <language-tag>
    --id <identifier>
    --uuid <dns-name>
"""
_FILE_LIST_DESCRIPTION_ = """\
File-list format:
    <file-list>  ::= <entry>+
    <entry> ::= <path> [ "\\t" <use-nav> [ "\\t" <caption> ] ] "\\n"
    <use-nav> ::= <index-title> | "-" | ""
    <caption>  ::= <content-caption> | "-"

    <path>
        A path to XHTML, SVG, or image file. That XHTML and SVG files are used
        as content documents (EPUB 3.2). Other each media file is embedded in a
        XHTML file. If you want to embed that SVG into XHTML, you should add a
        <content-caption>.
    <index-title>
        If it is specified which indicates that document linked from a table of
        contents.
        If it is specified to "-", the content document's title or the basename
        of the file is used as the index title.
    <content-caption>
        When the <path> points to a SVG and this cell is specified, the SVG is
        embedded in a XHTML file. Then, if it is "-", this value is the SVG's
        title data or the basename of the file.
"""

def arg_parser():
    parser = argparse.ArgumentParser(
        prog='tinyepubbuild',
        description='This is a tool to buid epub from a formatted file-list readable on the standard input.',
        epilog=_FILE_LIST_DESCRIPTION_)
    
    parser.add_argument('--unzipped', action='store_true', help='make a package unzipped')
    parser.add_argument('packagename', metavar='package-name', help='EPUB Package directory')
    parser.add_argument('-c', '--cover', metavar='cover-image',
                        help='path to the cover-image')
    parser.add_argument('-t', '--title', metavar='title',
                        help='if it is not, <package-name> is used for a title')
    parser.add_argument('-l', '--language', metavar='language-tag',
                        help='if it is not, use the `lang` attribute of the content documents. if there is no `lang` attribute, use the `os.environ["LANG"]`')
    parser.add_argument('-a', '--author',
                        help='used for <dc:creator> element of the package document')
    parser.add_argument('--id', metavar='identifier',
                        help='used for <dc:identifier> element of the package document')
    parser.add_argument('--uuid', metavar='dns-name', help='if the <identifier> is not specified, use this value for generate the package unique identifier with `uuid5(NAMESPACE_DNS, <dns-name>)`. if both are not specified, generated by `uuid4()`')
    return parser

def main():
    arg_parser = arg_parser()
    args = arg_parser.parse_args()
    try:
        file_list_parser = reader.FileListParser()
        package_spec = file_list_parser.parse(sys.stdin)
        
        package_spec.cover_image = args.cover
        package_spec.book_title = args.title if args.title is not None else args.packagename
        if args.author:
            package_spec.author = args.author
        package_spec.language_tag = args.language
        package_spec.id = args.id if args.id is not None else None
        package_spec.uuid = args.uuid

        builder = builder.PackageBuilder(args.packagename)
        builder.build_with(pakage_spec)

        if not args.unzipped:
            builder.zipup()
    except:
        arg_parser.print_help()
    
if __name__ == '__main__':
    main()
